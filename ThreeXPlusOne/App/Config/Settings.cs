using System.Security.Cryptography;
using System.Text;
using System.Text.Json.Serialization;
using ThreeXPlusOne.App.Enums;

namespace ThreeXPlusOne.App.Config;

/// <summary>
/// If no settings file is supplied, the defaults set here would be used
/// </summary>
public class Settings
{
    [JsonIgnore]
    private string? _uniqueExecutionId;

    [JsonIgnore]
    private readonly GraphProvider _graphProvider = GraphProvider.SkiaSharp;

    [JsonIgnore]
    private static readonly char[] _separator = [','];

    /// <summary>
    /// The amount of numbers to randomly generate to run through the algorithm
    /// </summary>
    [Setting(description: "The total number of series that will be generated by the algorithm.", suggestedValue: "200")]
    public int NumberOfSeries { get; set; } = 200;

    /// <summary>
    /// The max value that the randomly selected numbers can be
    /// </summary>
    [Setting(description: "The highest possible starting number of any given series.", suggestedValue: "1000")]
    public int MaxStartingNumber { get; set; } = 1000;

    /// <summary>
    /// If supplied, the algorithm will be run only on these numbers
    /// </summary>
    [Setting(description: $"A comma-separated list of numbers to run the program with. Overrides {nameof(NumberOfSeries)} and {nameof(MaxStartingNumber)}.", suggestedValue: "")]
    public string UseTheseNumbers { get; set; } = "";

    /// <summary>
    /// If supplied, these numbers will be excluded from either random number selection or from the UseTheseNumbers property
    /// </summary>
    [Setting(description: "A comma-separated list of numbers not to use.", suggestedValue: "")]
    public string ExcludeTheseNumbers { get; set; } = "";

    /// <summary>
    /// The angle by which a node will be rotated by on the graph
    /// </summary>
    /// <remarks>
    /// If the node value is even, it is rotated clockwise. If odd, anti-clockwise
    /// </remarks>
    [Setting(description: "The magnitude of the rotation angle. 0 is no rotation. When using rotation, start small, such as 0.8", suggestedValue: "0")]
    public double NodeRotationAngle { get; set; } = 0;

    /// <summary>
    /// The radius of the node
    /// </summary>
    [Setting(description: "The radius of the nodes in pixels.", suggestedValue: "50 for 2D, 275 for 3D")]
    public double NodeRadius { get; set; } = 50;

    /// <summary>
    /// Hex values to be used for node colours
    /// </summary>
    [Setting(description: "Comma-separated list of hex codes to use as colours for the nodes. Leave blank to use randomly-selected colours.", suggestedValue: "")]
    public string NodeColors { get; set; } = "";

    /// <summary>
    /// Whether or not to draw polygons as nodes in addition to circles
    /// </summary>
    [Setting(description: "Whether or not to use polygons in addition to circles as graph nodes.", suggestedValue: "false")]
    public bool IncludePolygonsAsNodes { get; set; }

    /// <summary>
    /// The amount of x-axis space in pixels by which to separate nodes
    /// </summary>
    [Setting(description: "The default space between nodes on the x-axis.", suggestedValue: "125 for 2D, 250 for 3D")]
    public int XNodeSpacer { get; set; } = 125;

    /// <summary>
    /// The amount of y-axis space in pixels by which to separate nodes
    /// </summary>
    [Setting(description: "The default space between nodes on the y-axis.", suggestedValue: "125 for 2D, 225 for 3D")]
    public int YNodeSpacer { get; set; } = 125;

    /// <summary>
    /// For pseudo-3D graphs, the distance from the viewer (to create perspective)
    /// </summary>
    [Setting(description: "For the psuedo-3D graph, the distance from the view when applying the perspective transformation.", suggestedValue: "200")]
    public double DistanceFromViewer { get; set; } = 200;

    /// <summary>
    /// The number of dimensions to render in the graph
    /// </summary>
    /// <remarks>2 or 3</remarks>
    [Setting(description: "The number of dimensions to render in the graph. Values are: 2, 3", suggestedValue: "2")]
    public int GraphDimensions { get; set; } = 2;

    /// <summary>
    /// The position of the light source. Use "None" to not generate the light source.
    /// </summary>
    [Setting(description: "The position of the light source. Values are: {LightSourcePositionsPlaceholder}", suggestedValue: "None")]
    public string LightSourcePosition { get; set; } = "None";

    /// <summary>
    /// Whether or not to draw the connections between nodes on the graph
    /// </summary>
    [Setting(description: "Whether or not to draw connections between the nodes in the graph. If set to true, image file size may increase substantially.", suggestedValue: "true")]
    public bool DrawConnections { get; set; } = true;

    /// <summary>
    /// Whether or not to draw the number at the center of the node that the node represents
    /// </summary>
    [Setting(description: "Whether or not to draw the numbers at the center of the node that the node represents.", suggestedValue: "true")]
    public bool DrawNumbersOnNodes { get; set; } = true;

    /// <summary>
    /// Whether or not to draw stars on the graph's background
    /// </summary>
    [Setting(description: "Whether or not to generate random points of white light in the background of the graph.", suggestedValue: "false")]
    public bool GenerateBackgroundStars { get; set; }

    /// <summary>
    /// The directory in which the process will create a unique execution folder with generated output
    /// </summary>
    [Setting(description: "The folder in which the generated output files should be placed", suggestedValue: "C:\\path\\to\\save\\output\\")]
    public string OutputPath { get; set; } = "";

    /// <summary>
    /// The graph provider to use to render the graph image
    /// </summary>
    [JsonIgnore]
    public GraphProvider GraphProvider
    {
        get
        {
            return _graphProvider;
        }
    }

    /// <summary>
    /// The name of the file in which these settings are stored
    /// </summary>
    [JsonIgnore]
    public string SettingsFileName { get; set; } = "";

    /// <summary>
    /// The full path to the settings file (could be provided by the user)
    /// </summary>
    [JsonIgnore]
    public string SettingsFileFullPath { get; set; } = "";

    /// <summary>
    /// An MD5 hash used to name a directory to store the output for the run of the given number series
    /// </summary>
    [JsonIgnore]
    public string UniqueExecutionId
    {
        get
        {
            if (string.IsNullOrEmpty(_uniqueExecutionId))
            {
                _uniqueExecutionId = ComputeHashFromSeriesData();
            }

            return _uniqueExecutionId;
        }
    }

    /// <summary>
    /// The sanitized graph dimensions property
    /// </summary>
    [JsonIgnore]
    public int SanitizedGraphDimensions
    {
        get
        {
            if (GraphDimensions < 2 || GraphDimensions > 3)
            {
                return 2;
            }

            return GraphDimensions;
        }
    }

    /// <summary>
    /// The series numbers parsed as a list of integers
    /// </summary>
    [JsonIgnore]
    public List<int> ListOfSeriesNumbers
    {
        get
        {
            var parsedNumbers = new List<int>();

            if (string.IsNullOrWhiteSpace(UseTheseNumbers))
            {
                return parsedNumbers;
            }

            string[] stringArray = UseTheseNumbers.Split(_separator, StringSplitOptions.RemoveEmptyEntries);

            foreach (string numberAsString in stringArray)
            {
                if (int.TryParse(numberAsString, out int parsedNumber))
                {
                    if (parsedNumber <= 0)
                    {
                        continue;
                    }

                    parsedNumbers.Add(parsedNumber);
                }
            }

            return parsedNumbers;
        }
    }

    /// <summary>
    /// The number to exclude parsed as a list of integers
    /// </summary>
    [JsonIgnore]
    public List<int> ListOfNumbersToExclude
    {
        get
        {
            var parsedNumbers = new List<int>();

            if (string.IsNullOrWhiteSpace(ExcludeTheseNumbers))
            {
                return parsedNumbers;
            }

            string[] stringArray = ExcludeTheseNumbers.Split(_separator, StringSplitOptions.RemoveEmptyEntries);

            foreach (var numberAsString in stringArray)
            {
                if (int.TryParse(numberAsString, out int parsedNumber))
                {
                    parsedNumbers.Add(parsedNumber);
                }
            }

            return parsedNumbers;
        }
    }

    /// <summary>
    /// Create an MD5 hash of the list of numbers that the process is running on such that
    /// the output directory can be uniquely named and re-used if the process is re-run with the same numbers
    /// </summary>
    /// <returns></returns>
    private string ComputeHashFromSeriesData()
    {
        List<int> copyOfSeriesNumbers = ListOfSeriesNumbers;
        copyOfSeriesNumbers.RemoveAll(ListOfNumbersToExclude.Contains);

        byte[] bytes = MD5.HashData(Encoding.UTF8.GetBytes(string.Join("", copyOfSeriesNumbers.OrderBy(x => x))));

        StringBuilder builder = new();

        for (int i = 0; i < bytes.Length; i++)
        {
            builder.Append(bytes[i].ToString("x2"));
        }

        return builder.ToString().ToLower();
    }
}