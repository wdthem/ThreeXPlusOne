using Microsoft.Extensions.Options;
using System.Drawing;
using ThreeXPlusOne.App.Enums;
using ThreeXPlusOne.App.Interfaces.Helpers;
using ThreeXPlusOne.App.Interfaces.Services;
using ThreeXPlusOne.App.Models;
using ThreeXPlusOne.Config;

namespace ThreeXPlusOne.App.Graph;

public abstract partial class DirectedGraph(IOptions<Settings> settings,
                                            IEnumerable<IDirectedGraphService> graphServices,
                                            ILightSourceService lightSourceService,
                                            IConsoleHelper consoleHelper)
{
    private int _canvasWidth = 0;
    private int _canvasHeight = 0;

    protected readonly Settings _settings = settings.Value;
    protected readonly IConsoleHelper _consoleHelper = consoleHelper;
    protected readonly NodePositions _nodePositions = new(consoleHelper);
    protected readonly Dictionary<int, DirectedGraphNode> _nodes = [];

    /// <summary>
    /// Add multiple series of numbers to the graph generated by the algorithm
    /// </summary>
    /// <param name="seriesLists"></param>
    public void AddSeries(List<List<int>> seriesLists)
    {
        _consoleHelper.Write($"Adding {seriesLists.Count} series to the graph... ");

        foreach (List<int> series in seriesLists)
        {
            DirectedGraphNode? previousNode = null;
            int currentDepth = series.Count;

            foreach (int number in series)
            {
                if (!_nodes.TryGetValue(number, out DirectedGraphNode? currentNode))
                {
                    currentNode = new DirectedGraphNode(number)
                    {
                        Depth = currentDepth
                    };

                    _nodes.Add(number, currentNode);
                }

                // Check if this is a deeper path to the current node
                if (currentDepth < currentNode.Depth)
                {
                    currentNode.Depth = currentDepth;
                }

                if (previousNode != null)
                {
                    previousNode.Parent = currentNode;

                    // Check if previousNode is already a child to prevent duplicate additions
                    if (!currentNode.Children.Contains(previousNode))
                    {
                        previousNode.IsFirstChild = true;

                        //if this node already has a child, turn off the flag
                        if (currentNode.Children.Count == 1)
                        {
                            previousNode.IsFirstChild = false;
                        }

                        currentNode.Children.Add(previousNode);
                    }
                }

                previousNode = currentNode;

                currentDepth--;
            }

            int maxNodeDepth = _nodes.Values.Max(node => node.Depth);

            foreach (DirectedGraphNode node in _nodes.Values)
            {
                node.Z = maxNodeDepth - node.Depth;
            }
        }

        _consoleHelper.WriteDone();
    }

    /// <summary>
    /// Draw the directed graph
    /// </summary>
    /// <exception cref="Exception"></exception>
    protected void DrawDirectedGraph()
    {
        IDirectedGraphService graphService = graphServices.ToList()
                                                          .Where(graphService => graphService.GraphProvider == _settings.GraphProvider)
                                                          .First();

        if (!graphService.SupportedDimensions.Contains(_settings.SanitizedGraphDimensions))
        {
            throw new Exception($"Graph provider {_settings.GraphProvider} does not support graphs in {_settings.SanitizedGraphDimensions} dimensions.");
        }

        graphService.OnStart = (message) =>
        {
            _consoleHelper.Write(message);
            _consoleHelper.ShowSpinningBar();
        };

        graphService.OnComplete = () =>
        {
            _consoleHelper.StopSpinningBar();
            _consoleHelper.WriteDone();
        };

        Task.Run(() => graphService.Initialize([.. _nodes.Values],
                                               _canvasWidth,
                                               _canvasHeight,
                                               Color.Black)).Wait();


        if (_settings.GenerateBackgroundStars)
        {
            Task.Run(() => graphService.GenerateBackgroundStars(100)).Wait();
        }

        lightSourceService.Initialize(_canvasWidth,
                                      _canvasHeight,
                                      _settings.SanitizedGraphDimensions,
                                      _settings.LightSourcePosition);

        if (lightSourceService.LightSourcePosition != LightSourcePosition.None)
        {
            Task.Run(() => graphService.GenerateLightSource(lightSourceService.GetLightSourceCoordinates(lightSourceService.LightSourcePosition),
                                                            lightSourceService.Radius,
                                                            lightSourceService.LightSourceColor)).Wait();
        }

        foreach (DirectedGraphNode node in _nodes.Values)
        {
            Color nodeColor = NodeAesthetics.GenerateNodeColor();

            if (lightSourceService.LightSourcePosition == LightSourcePosition.None)
            {
                node.Shape.Color = nodeColor;
            }
            else
            {
                NodeAesthetics.ApplyLightSourceToNode(node,
                                                      nodeColor,
                                                      lightSourceService.GetLightSourceCoordinates(lightSourceService.LightSourcePosition),
                                                      lightSourceService.GetLightSourceMaxDistanceOfEffect(),
                                                      lightSourceService.LightSourceColor);
            }
        }

        Task.Run(() => graphService.Draw(drawNumbersOnNodes: _settings.DrawNumbersOnNodes,
                                         drawNodeConnections: _settings.DrawConnections)).Wait();

        Task.Run(graphService.Render).Wait();

        //saving the image is processing-intensive and can cause threading issues, so start it via Task.Factory
        //in order to specify that it is expected to be long-running
        Task.Factory.StartNew(graphService.SaveImage,
                              CancellationToken.None,
                              TaskCreationOptions.LongRunning,
                              TaskScheduler.Default).Wait();

        Task.Run(graphService.Dispose).Wait();
    }

    /// <summary>
    /// Set the canvas dimensions to a bit more than the bounding box of all the nodes
    /// </summary>
    protected void SetCanvasSize()
    {
        double maxX = _nodes.Values.Max(node => node.Position.X);
        double maxY = _nodes.Values.Max(node => node.Position.Y);

        _canvasWidth = (int)(maxX + _settings.XNodeSpacer + _settings.NodeRadius);
        _canvasHeight = (int)(maxY + _settings.YNodeSpacer + _settings.NodeRadius);

        _consoleHelper.WriteLine($"Canvas dimensions set to {_canvasWidth}w x {_canvasHeight}h (in pixels)\n");
    }

    /// <summary>
    /// Calculate the Euclidean distance between two node positions
    /// </summary>
    /// <param name="position1"></param>
    /// <param name="position2"></param>
    /// <returns></returns>
    protected static double Distance((double X, double Y) position1,
                                     (double X, double Y) position2)
    {
        return Math.Sqrt(Math.Pow(position2.X - position1.X, 2) + Math.Pow(position2.Y - position1.Y, 2));
    }
}