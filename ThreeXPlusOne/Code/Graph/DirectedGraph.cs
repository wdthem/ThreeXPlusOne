using Microsoft.Extensions.Options;
using ThreeXPlusOne.Code.Interfaces;
using ThreeXPlusOne.Config;
using ThreeXPlusOne.Models;

namespace ThreeXPlusOne.Code.Graph;

public abstract class DirectedGraph(IOptions<Settings> settings,
                                    IEnumerable<IGraphService> graphServices,
                                    IFileHelper fileHelper,
                                    IConsoleHelper consoleHelper)
{
    private int _canvasWidth = 0;
    private int _canvasHeight = 0;
    protected readonly Random _random = new();
    protected readonly Settings _settings = settings.Value;
    protected readonly IFileHelper _fileHelper = fileHelper;
    protected readonly IConsoleHelper _consoleHelper = consoleHelper;
    protected readonly Dictionary<int, DirectedGraphNode> _nodes = [];
    private readonly Dictionary<(int, int), List<(float X, float Y)>> _nodeGrid = [];

    /// <summary>
    /// Add multiple series of numbers to the graph generated by the algorithm
    /// </summary>
    /// <param name="seriesLists"></param>
    public void AddSeries(List<List<int>> seriesLists)
    {
        _consoleHelper.Write($"Adding {seriesLists.Count} series to the graph... ");

        foreach (List<int> series in seriesLists)
        {
            DirectedGraphNode? previousNode = null;
            int currentDepth = series.Count;

            foreach (var number in series)
            {
                if (!_nodes.TryGetValue(number, out DirectedGraphNode? currentNode))
                {
                    currentNode = new DirectedGraphNode(number)
                    {
                        Depth = currentDepth
                    };

                    _nodes.Add(number, currentNode);
                }

                // Check if this is a deeper path to the current node
                if (currentDepth < currentNode.Depth)
                {
                    currentNode.Depth = currentDepth;
                }

                if (previousNode != null)
                {
                    previousNode.Parent = currentNode;

                    // Check if previousNode is already a child to prevent duplicate additions
                    if (!currentNode.Children.Contains(previousNode))
                    {
                        previousNode.IsFirstChild = true;

                        //if this node already has a child, turn off the flag
                        if (currentNode.Children.Count == 1)
                        {
                            previousNode.IsFirstChild = false;
                        }

                        currentNode.Children.Add(previousNode);
                    }
                }

                previousNode = currentNode;

                currentDepth--;
            }

            int maxNodeDepth = _nodes.Max(node => node.Value.Depth);

            foreach (var node in _nodes)
            {
                node.Value.Z = maxNodeDepth - node.Value.Depth;
            }
        }

        _consoleHelper.WriteDone();
    }

    /// <summary>
    /// Draw the directed graph
    /// </summary>
    protected void DrawDirectedGraph()
    {
        IGraphService graphService = graphServices.ToList()
                                                  .Where(graphService => graphService.GraphProvider == _settings.GraphProvider)
                                                  .First();

        graphService.InitializeGraph(_canvasWidth, _canvasHeight);

        if (_settings.GenerateBackgroundStars)
        {
            graphService.GenerateBackgroundStars(100);
        }

        _consoleHelper.WriteLine("");

        var lcv = 0;
        if (_settings.DrawConnections)
        {
            foreach (var node in _nodes)
            {
                graphService.DrawConnection(node.Value);

                _consoleHelper.Write($"\r{lcv} connections drawn... ");

                lcv += 1;
            }

            _consoleHelper.WriteDone();
        }

        lcv = 1;
        foreach (var node in _nodes)
        {
            graphService.DrawNode(node.Value,
                                  _settings.DrawNumbersOnNodes,
                                  _settings.DistortNodes);

            _consoleHelper.Write($"\r{lcv} nodes drawn... ");

            lcv += 1;
        }

        _consoleHelper.WriteDone();

        graphService.SaveGraphImage();
    }

    /// <summary>
    /// The graph starts out at 0,0 with 0 width and 0 height. This means that nodes go into negative space as they are initially positioned, 
    /// so all coordinates need to be shifted to make sure all are in positive space
    /// </summary>
    protected void MoveNodesToPositiveCoordinates()
    {
        _consoleHelper.Write("Adjusting node positions to fit on canvas... ");

        float minX = _nodes.Min(node => node.Value.Position.X);
        float minY = _nodes.Min(node => node.Value.Position.Y);

        float translationX = minX < 0 ? -minX + 500 : 0;
        float translationY = minY < 0 ? -minY + 500 : 0;

        foreach (var node in _nodes)
        {
            node.Value.Position = (node.Value.Position.X + translationX,
                                   node.Value.Position.Y + translationY);
        }

        _consoleHelper.WriteDone();
    }

    /// <summary>
    /// Set the canvas dimensions to a bit more than the bounding box of all the nodes
    /// </summary>
    protected void SetCanvasSize()
    {
        float maxX = _nodes.Max(node => node.Value.Position.X);
        float maxY = _nodes.Max(node => node.Value.Position.Y);

        _canvasWidth = (int)maxX + 500;
        _canvasHeight = (int)maxY + 500;

        _consoleHelper.WriteLine($"Canvas dimensions set to {_canvasWidth}w x {_canvasHeight}h (in pixels)\n");
    }

    /// <summary>
    /// Determine if the node that was just positioned is too close to neighbouring nodes (and thus overlapping)
    /// </summary>
    /// <param name="newNode"></param>
    /// <param name="minDistance"></param>
    /// <returns></returns>
    protected bool NodeIsTooCloseToNeighbours(DirectedGraphNode newNode, float minDistance)
    {
        (int, int) cell = GetGridCellForNode(newNode, minDistance);

        // Check this cell and adjacent cells
        foreach ((int, int) offset in new[] { (0, 0), (1, 0), (0, 1), (-1, 0), (0, -1) })
        {
            (int, int) checkCell = (cell.Item1 + offset.Item1,
                                    cell.Item2 + offset.Item2);

            if (_nodeGrid.TryGetValue(checkCell, out var nodesInCell))
            {
                foreach (var node in nodesInCell)
                {
                    if (Distance(newNode.Position, node) < minDistance)
                    {
                        return true;
                    }
                }
            }
        }

        return false;
    }

    /// <summary>
    /// Add the node to the grid dictionary to keep track of node positions via a grid system
    /// </summary>
    /// <param name="node"></param>
    /// <param name="minDistance"></param>
    protected void AddNodeToGrid(DirectedGraphNode node, float minDistance)
    {
        (int, int) cell = GetGridCellForNode(node, minDistance);

        if (!_nodeGrid.TryGetValue(cell, out List<(float X, float Y)>? value))
        {
            value = ([]);
            _nodeGrid[cell] = value;
        }

        value.Add(node.Position);
    }

    /// <summary>
    /// Calculate the Euclidean distance between two node positions
    /// </summary>
    /// <param name="point1"></param>
    /// <param name="point2"></param>
    /// <returns></returns>
    protected static float Distance((float X, float Y) point1, (float X, float Y) point2)
    {
        return (float)Math.Sqrt(Math.Pow(point2.X - point1.X, 2) + Math.Pow(point2.Y - point1.Y, 2));
    }

    /// <summary>
    /// Calculate the signed X-axis distance from a parent to a child node
    /// </summary>
    /// <remarks>
    /// Negative if child is the to left of the parent, positive if to the right
    /// </remarks>
    /// <param name="child"></param>
    /// <param name="parent"></param>
    /// <returns></returns>
    protected static float XAxisSignedDistanceFromParent((float X, float Y) child, (float X, float Y) parent)
    {
        return child.X - parent.X;
    }

    /// <summary>
    /// Rotate the node's position anti-clockwise based on the angle provided by the user. This gives a more artistic feel to the generated graph.
    /// </summary>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="angleDegrees"></param>
    /// <returns></returns>
    protected static (double x, double y) RotatePointAntiClockwise(double x, double y, double angleDegrees)
    {
        double angleRadians = angleDegrees * Math.PI / 180.0; // Convert angle to radians

        double cosTheta = Math.Cos(angleRadians);
        double sinTheta = Math.Sin(angleRadians);

        double xNew = cosTheta * x - sinTheta * y;
        double yNew = sinTheta * x + cosTheta * y;

        return (xNew, yNew);
    }

    /// <summary>
    /// Rotate the node's position clockwise based on the angle provided by the user. This gives a more artistic feel to the generated graph.
    /// </summary>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="angleDegrees"></param>
    /// <returns></returns>
    protected static (double x, double y) RotatePointClockwise(double x, double y, double angleDegrees)
    {
        double angleRadians = angleDegrees * Math.PI / 180.0; // Convert angle to radians

        double cosTheta = Math.Cos(angleRadians);
        double sinTheta = Math.Sin(angleRadians);

        double xNew = cosTheta * x + sinTheta * y;
        double yNew = -sinTheta * x + cosTheta * y;

        return (xNew, yNew);
    }

    /// <summary>
    /// Retrieve the cell in the grid object in which the node is positioned
    /// </summary>
    /// <param name="node"></param>
    /// <param name="cellSize"></param>
    /// <returns></returns>
    private static (int, int) GetGridCellForNode(DirectedGraphNode node, float cellSize)
    {
        return ((int)(node.Position.X / cellSize), (int)(node.Position.Y / cellSize));
    }
}