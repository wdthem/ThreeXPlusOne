using Microsoft.Extensions.Options;
using SkiaSharp;
using ThreeXPlusOne.Code.Interfaces;
using ThreeXPlusOne.Config;
using ThreeXPlusOne.Models;

namespace ThreeXPlusOne.Code.Graph;

public abstract class DirectedGraph(IOptions<Settings> settings,
                                    IFileHelper fileHelper,
                                    IConsoleHelper consoleHelper)
{
    private int _canvasWidth = 0;
    private int _canvasHeight = 0;
    protected readonly Random _random = new();
    protected readonly Settings _settings = settings.Value;
    protected readonly IFileHelper _fileHelper = fileHelper;
    protected readonly IConsoleHelper _consoleHelper = consoleHelper;
    protected readonly Dictionary<int, DirectedGraphNode> _nodes = [];
    private readonly Dictionary<(int, int), List<(float X, float Y)>> _nodeGrid = [];

    /// <summary>
    /// Add multiple series of numbers to the graph generated by the algorithm
    /// </summary>
    /// <param name="seriesLists"></param>
    public void AddSeries(List<List<int>> seriesLists)
    {
        _consoleHelper.Write($"Adding {seriesLists.Count} series to the graph... ");

        foreach (List<int> series in seriesLists)
        {
            DirectedGraphNode? previousNode = null;
            int currentDepth = series.Count;

            foreach (var number in series)
            {
                if (!_nodes.TryGetValue(number, out DirectedGraphNode? currentNode))
                {
                    currentNode = new DirectedGraphNode(number)
                    {
                        Depth = currentDepth
                    };

                    _nodes.Add(number, currentNode);
                }

                // Check if this is a deeper path to the current node
                if (currentDepth < currentNode.Depth)
                {
                    currentNode.Depth = currentDepth;
                }

                if (previousNode != null)
                {
                    previousNode.Parent = currentNode;

                    // Check if previousNode is already a child to prevent duplicate additions
                    if (!currentNode.Children.Contains(previousNode))
                    {
                        previousNode.IsFirstChild = true;

                        if (currentNode.Children.Count == 1)
                        {
                            previousNode.IsFirstChild = false;
                        }

                        currentNode.Children.Add(previousNode);
                    }
                }

                previousNode = currentNode;

                currentDepth--;
            }

            int maxNodeDepth = _nodes.Max(node => node.Value.Depth);

            foreach (var node in _nodes)
            {
                node.Value.Z = maxNodeDepth - node.Value.Depth;
            }
        }

        _consoleHelper.WriteDone();
    }

    /// <summary>
    /// Draw the directed graph
    /// </summary>
    protected void DrawDirectedGraph()
    {
        using var surface = SKSurface.Create(new SKImageInfo(_canvasWidth, _canvasHeight));

        SKCanvas canvas = surface.Canvas;

        canvas.Clear(SKColors.Black);

        if (_settings.GenerateBackgroundStars)
        {
            GenerateBackgroundStars(canvas, 100);
        }

        _consoleHelper.WriteLine("");

        var lcv = 0;
        if (_settings.DrawConnections)
        {
            foreach (var node in _nodes)
            {
                DrawConnection(canvas, node.Value);

                _consoleHelper.Write($"\r{lcv} connections drawn... ");

                lcv += 1;
            }

            _consoleHelper.WriteDone();
        }

        lcv = 1;
        foreach (var node in _nodes)
        {
            DrawNode(canvas, node.Value);

            _consoleHelper.Write($"\r{lcv} nodes drawn... ");

            lcv += 1;
        }

        _consoleHelper.WriteDone();

        SaveCanvas(surface);
    }

    /// <summary>
    /// The graph starts out at 0,0 with 0 width and 0 height. This means that nodes go into negative space as they are initially positioned, 
    /// so all coordinates need to be shifted to make sure all are in positive space
    /// </summary>
    protected void MoveNodesToPositiveCoordinates()
    {
        _consoleHelper.Write("Adjusting node positions to fit on canvas... ");

        float minX = _nodes.Min(node => node.Value.Position.X);
        float minY = _nodes.Min(node => node.Value.Position.Y);

        float translationX = minX < 0 ? -minX + 500 : 0;
        float translationY = minY < 0 ? -minY + 500 : 0;

        foreach (var node in _nodes)
        {
            node.Value.Position = (node.Value.Position.X + translationX,
                                   node.Value.Position.Y + translationY);
        }

        _consoleHelper.WriteDone();
    }

    /// <summary>
    /// Set the canvas dimensions to a bit more than the bounding box of all the nodes
    /// </summary>
    protected void SetCanvasSize()
    {
        float maxX = _nodes.Max(node => node.Value.Position.X);
        float maxY = _nodes.Max(node => node.Value.Position.Y);

        _canvasWidth = (int)maxX + 500;
        _canvasHeight = (int)maxY + 500;

        _consoleHelper.WriteLine($"Canvas dimensions set to {_canvasWidth}w x {_canvasHeight}h (in pixels)\n");
    }

    /// <summary>
    /// Determine if the node that was just positioned is too close to neighbouring nodes (and thus overlapping)
    /// </summary>
    /// <param name="newNode"></param>
    /// <param name="minDistance"></param>
    /// <returns></returns>
    protected bool NodeIsTooCloseToNeighbours(DirectedGraphNode newNode, float minDistance)
    {
        (int, int) cell = GetGridCellForNode(newNode, minDistance);

        // Check this cell and adjacent cells
        foreach ((int, int) offset in new[] { (0, 0), (1, 0), (0, 1), (-1, 0), (0, -1) })
        {
            (int, int) checkCell = (cell.Item1 + offset.Item1,
                                    cell.Item2 + offset.Item2);

            if (_nodeGrid.TryGetValue(checkCell, out var nodesInCell))
            {
                foreach (var node in nodesInCell)
                {
                    if (Distance(newNode.Position, node) < minDistance)
                    {
                        return true;
                    }
                }
            }
        }

        return false;
    }

    /// <summary>
    /// Add the node to the grid dictionary to keep track of node positions via a grid system
    /// </summary>
    /// <param name="node"></param>
    /// <param name="minDistance"></param>
    protected void AddNodeToGrid(DirectedGraphNode node, float minDistance)
    {
        (int, int) cell = GetGridCellForNode(node, minDistance);

        if (!_nodeGrid.TryGetValue(cell, out List<(float X, float Y)>? value))
        {
            value = ([]);
            _nodeGrid[cell] = value;
        }

        value.Add(node.Position);
    }

    /// <summary>
    /// Calculate the Euclidean distance between two node positions
    /// </summary>
    /// <param name="point1"></param>
    /// <param name="point2"></param>
    /// <returns></returns>
    protected static float Distance((float X, float Y) point1, (float X, float Y) point2)
    {
        return (float)Math.Sqrt(Math.Pow(point2.X - point1.X, 2) + Math.Pow(point2.Y - point1.Y, 2));
    }

    /// <summary>
    /// Calculate the signed X-axis distance from a parent to a child node
    /// </summary>
    /// <remarks>
    /// Negative if child is the to left of the parent, positive if to the right
    /// </remarks>
    /// <param name="child"></param>
    /// <param name="parent"></param>
    /// <returns></returns>
    protected static float XAxisSignedDistanceFromParent((float X, float Y) child, (float X, float Y) parent)
    {
        return child.X - parent.X;
    }

    /// <summary>
    /// Rotate the node's position anti-clockwise based on the angle provided by the user. This gives a more artistic feel to the generated graph.
    /// </summary>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="angleDegrees"></param>
    /// <returns></returns>
    protected static (double x, double y) RotatePointAntiClockwise(double x, double y, double angleDegrees)
    {
        double angleRadians = angleDegrees * Math.PI / 180.0; // Convert angle to radians

        double cosTheta = Math.Cos(angleRadians);
        double sinTheta = Math.Sin(angleRadians);

        double xNew = cosTheta * x - sinTheta * y;
        double yNew = sinTheta * x + cosTheta * y;

        return (xNew, yNew);
    }

    /// <summary>
    /// Rotate the node's position clockwise based on the angle provided by the user. This gives a more artistic feel to the generated graph.
    /// </summary>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="angleDegrees"></param>
    /// <returns></returns>
    protected static (double x, double y) RotatePointClockwise(double x, double y, double angleDegrees)
    {
        double angleRadians = angleDegrees * Math.PI / 180.0; // Convert angle to radians

        double cosTheta = Math.Cos(angleRadians);
        double sinTheta = Math.Sin(angleRadians);

        double xNew = cosTheta * x + sinTheta * y;
        double yNew = -sinTheta * x + cosTheta * y;

        return (xNew, yNew);
    }

    /// <summary>
    /// Retrieve the cell in the grid object in which the node is positioned
    /// </summary>
    /// <param name="node"></param>
    /// <param name="cellSize"></param>
    /// <returns></returns>
    private static (int, int) GetGridCellForNode(DirectedGraphNode node, float cellSize)
    {
        return ((int)(node.Position.X / cellSize), (int)(node.Position.Y / cellSize));
    }

    /// <summary>
    /// Draw the lines connecting nodes to their parent/children
    /// </summary>
    /// <param name="canvas"></param>
    /// <param name="node"></param>
    private static void DrawConnection(SKCanvas canvas, DirectedGraphNode node)
    {
        SKPaint paint = new()
        {
            Color = new SKColor(255, 255, 255, 128),
            StrokeWidth = 2,
            IsAntialias = true
        };

        foreach (DirectedGraphNode childNode in node.Children)
        {
            canvas.DrawLine(new SKPoint(node.Position.X, node.Position.Y),
                            new SKPoint(childNode.Position.X, childNode.Position.Y),
                            paint);
        }
    }

    /// <summary>
    /// Draw the node at its defined position
    /// </summary>
    /// <param name="canvas"></param>
    /// <param name="node"></param>
    private void DrawNode(SKCanvas canvas, DirectedGraphNode node)
    {
        SKPaint paint = new()
        {
            IsAntialias = true,
            Style = SKPaintStyle.Fill,
            Color = GetRandomNodeColor((byte)_random.Next(30, 211))
        };

        SKPaint textPaint = new()
        {
            Color = SKColors.White,
            IsAntialias = true,
            Style = SKPaintStyle.Fill,
            TextAlign = SKTextAlign.Center,
            TextSize = 20,
            FakeBoldText = true,
        };

        if (_settings.DistortNodes)
        {
            DrawDistortedPath(canvas,
                              new SKPoint(node.Position.X, node.Position.Y),
                              node.Radius,
                              _settings.RadiusDistortion,
                              paint);
        }
        else
        {
            canvas.DrawCircle(new SKPoint(node.Position.X, node.Position.Y),
                              node.Radius,
                              paint);
        }

        if (_settings.DrawNumbersOnNodes)
        {
            // Draw the text
            // Adjust the Y coordinate to account for text height (this centers the text vertically in the circle)
            float textY = node.Position.Y + 8;

            canvas.DrawText(node.Value.ToString(), node.Position.X, textY, textPaint);
        }
    }

    /// <summary>
    /// Get a random non-black color for the given node
    /// </summary>
    /// <param name="alpha"></param>
    /// <returns></returns>
    private SKColor GetRandomNodeColor(byte alpha = 255)
    {
        byte red, green, blue;

        do
        {
            red = (byte)_random.Next(256);
            green = (byte)_random.Next(256);
            blue = (byte)_random.Next(256);
        }
        while (red <= 10 || green <= 10 || blue <= 10); //avoid very dark colours

        return new SKColor(red, green, blue, alpha);
    }

    /// <summary>
    /// Instead of a circular node, draw a node of a distorted shape based on the user-defined distortion level
    /// </summary>
    /// <param name="canvas"></param>
    /// <param name="center"></param>
    /// <param name="baseRadius"></param>
    /// <param name="distortionLevel"></param>
    /// <param name="paint"></param>
    private void DrawDistortedPath(SKCanvas canvas,
                                   SKPoint center,
                                   float baseRadius,
                                   int distortionLevel,
                                   SKPaint paint)
    {
        SKPath path = new();
        int randomPointsCount = _random.Next(3, 11); //from 3 to 10

        path.MoveTo(center.X + baseRadius, center.Y);

        for (int i = 1; i <= randomPointsCount; i++)
        {
            float angle = (float)(2 * Math.PI / randomPointsCount * i);
            float radiusVariation = _random.Next(4, distortionLevel) + 1;
            float radius = baseRadius + radiusVariation;

            SKPoint point = new(center.X + radius * (float)Math.Cos(angle),
                                center.Y + radius * (float)Math.Sin(angle));

            path.LineTo(point);
        }

        path.Close();

        canvas.DrawPath(path, paint);
    }

    /// <summary>
    /// Optionally generate white points in the background to mimic stars
    /// </summary>
    /// <param name="canvas"></param>
    /// <param name="count"></param>
    private void GenerateBackgroundStars(SKCanvas canvas, int count)
    {
        List<SKPoint> points = [];

        for (int i = 0; i < count; i++)
        {
            float x = (float)_random.NextDouble() * _canvasWidth;
            float y = (float)_random.NextDouble() * _canvasHeight;

            points.Add(new SKPoint(x, y));
        }

        foreach (SKPoint point in points)
        {
            DrawStarWithBlur(canvas, point);
        }
    }

    /// <summary>
    /// Apply a blur effect to the stars
    /// </summary>
    /// <param name="canvas"></param>
    /// <param name="point"></param>
    private void DrawStarWithBlur(SKCanvas canvas, SKPoint point)
    {
        float starSize = _random.Next(20, 40);
        float blurRadius = 9.0f;

        SKPaint blurPaint = new()
        {
            IsAntialias = true,
            MaskFilter = SKMaskFilter.CreateBlur(SKBlurStyle.Normal, blurRadius)
        };

        SKPaint starPaint = new()
        {
            IsAntialias = true,
            Color = SKColors.White
        };

        canvas.DrawCircle(point, starSize, blurPaint);
        canvas.DrawCircle(point, starSize, starPaint);
    }

    /// <summary>
    /// Save the generated canvas
    /// </summary>
    /// <param name="surface"></param>
    private void SaveCanvas(SKSurface surface)
    {
        string path = _fileHelper.GenerateDirectedGraphFilePath();

        CancellationTokenSource cancellationTokenSource = new();
        CancellationToken token = cancellationTokenSource.Token;

        _consoleHelper.WriteLine($"Saving image to: {path}\n");
        _consoleHelper.Write("Please wait... ");

        Task spinner = Task.Run(() => _consoleHelper.WriteSpinner(token));

        using (SKImage image = surface.Snapshot())
        using (SKData data = image.Encode(SKEncodedImageFormat.Png, 25))
        using (FileStream stream = File.OpenWrite(path))
        {
            data.SaveTo(stream);
        }

        cancellationTokenSource.Cancel();

        spinner.Wait();
    }
}